/*_############################################################################
 * _##
 * _##  AGENT++ 4.5 - notification_log_mib.cpp
 * _##
 * _##  Copyright (C) 2000-2021  Frank Fock and Jochen Katz (agentpp.com)
 * _##
 * _##  Licensed under the Apache License, Version 2.0 (the "License");
 * _##  you may not use this file except in compliance with the License.
 * _##  You may obtain a copy of the License at
 * _##
 * _##      http://www.apache.org/licenses/LICENSE-2.0
 * _##
 * _##  Unless required by applicable law or agreed to in writing, software
 * _##  distributed under the License is distributed on an "AS IS" BASIS,
 * _##  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * _##  See the License for the specific language governing permissions and
 * _##  limitations under the License.
 * _##
 * _##########################################################################*/

#include <libagent.h>

//--AgentGen BEGIN=_BEGIN
#include <agent_pp/agent++.h>
#ifdef _SNMPv3
//--AgentGen END

#    include <agent_pp/notification_log_mib.h>

/**
 *  generated by AgentGen 1.6.2 for AGENT++v3.4
 * Sun Jun 03 23:58:42 GMT+02:00 2001.
 */

//--AgentGen BEGIN=_INCLUDE

#    include <agent_pp/mib_complex_entry.h>
#    include <agent_pp/snmp_notification_mib.h>
#    include <agent_pp/system_group.h>
#    include <agent_pp/vacm.h>
#    include <snmp_pp/log.h>

#    ifdef AGENTPP_NAMESPACE
namespace Agentpp
{
#    endif

#    ifndef _NO_LOGGING
static const char* loggerModuleName = "agent++.notification_log_mib";
#    endif

nlmConfigLogOperStatus::nlmConfigLogOperStatus(const Oidx& id)
    : MibLeaf(id, READONLY, new SnmpInt32(1), VMODE_DEFAULT)
{ }

nlmConfigLogOperStatus::~nlmConfigLogOperStatus() { }

void nlmConfigLogOperStatus::get_request(Request* req, int ind)
{
    uint32_t l = 1; // disabled(1)

    if (((nlmConfigLogAdminStatus*)my_row->get_nth(nNlmConfigLogAdminStatus))->get_state() == nlmConfigLogAdminStatus::e_enabled)
    {
        OctetStr const         f(((nlmConfigLogFilterName*)my_row->get_nth(0))->get_state());
        Oidx const             index(Oidx::from_string(f, true));
        snmpNotifyFilterEntry* snmpNotifyFilterEntry =
            snmpNotifyFilterEntry::get_instance(((nlmLogEntry*)my_table)->mib);
        if (snmpNotifyFilterEntry)
        {
            List<MibTableRow>* r = snmpNotifyFilterEntry->get_rows_cloned(&index, true);
            assert(r != nullptr);
            if (r->size() > 0)
            {
                l = 2;  // operational(2)
            }
            else
            {
                l = 3;  // noFilter(3)
            }
            delete r;
        }
    }

    *((SnmpInt32*)value) = l;
    MibLeaf::get_request(req, ind);
}

MibEntryPtr nlmConfigLogOperStatus::clone()
{
    MibEntryPtr other = new nlmConfigLogOperStatus(oid);

    ((nlmConfigLogOperStatus*)other)->replace_value(value->clone());
    ((nlmConfigLogOperStatus*)other)->set_reference_to_table(my_table);
    return other;
}

//--AgentGen END

/**
 *  nlmConfigGlobalEntryLimit
 *
 */

nlmConfigGlobalEntryLimit* nlmConfigGlobalEntryLimit::instance = nullptr;

nlmConfigGlobalEntryLimit::nlmConfigGlobalEntryLimit()
    : MibLeaf(oidNlmConfigGlobalEntryLimit, READWRITE, new Gauge32(0), VMODE_DEFAULT)
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer nlmConfigGlobalEntryLimit::instance.
    instance = this;

    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::nlmConfigGlobalEntryLimit
    //--AgentGen END
}

nlmConfigGlobalEntryLimit::~nlmConfigGlobalEntryLimit()
{
    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::~nlmConfigGlobalEntryLimit
    //--AgentGen END
}

void nlmConfigGlobalEntryLimit::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

uint32_t nlmConfigGlobalEntryLimit::get_state() { return (uint32_t) * ((Gauge32*)value); }

void nlmConfigGlobalEntryLimit::set_state(uint32_t l)
{
    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::set_state
    //--AgentGen END
    *((Gauge32*)value) = l;
}

int nlmConfigGlobalEntryLimit::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

bool nlmConfigGlobalEntryLimit::value_ok(const Vbx& /*vb*/)
{
    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::value_ok
    //--AgentGen END
    return true;
}

int nlmConfigGlobalEntryLimit::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = MibLeaf::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    //--AgentGen BEGIN=nlmConfigGlobalEntryLimit::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigGlobalEntryLimit
//--AgentGen END

/**
 *  nlmConfigGlobalAgeOut
 *
 */

nlmConfigGlobalAgeOut* nlmConfigGlobalAgeOut::instance = nullptr;

nlmConfigGlobalAgeOut::nlmConfigGlobalAgeOut()
    : MibLeaf(oidNlmConfigGlobalAgeOut, READWRITE, new Gauge32(1440), VMODE_DEFAULT)
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer nlmConfigGlobalAgeOut::instance.
    instance = this;

    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::nlmConfigGlobalAgeOut
    //--AgentGen END
}

nlmConfigGlobalAgeOut::~nlmConfigGlobalAgeOut()
{
    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::~nlmConfigGlobalAgeOut
    //--AgentGen END
}

void nlmConfigGlobalAgeOut::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

uint32_t nlmConfigGlobalAgeOut::get_state() { return (uint32_t) * ((Gauge32*)value); }

void nlmConfigGlobalAgeOut::set_state(uint32_t l)
{
    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::set_state
    //--AgentGen END
    *((Gauge32*)value) = l;
}

int nlmConfigGlobalAgeOut::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

bool nlmConfigGlobalAgeOut::value_ok(const Vbx& /*vb*/)
{
    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::value_ok
    //--AgentGen END
    return true;
}

int nlmConfigGlobalAgeOut::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = MibLeaf::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    //--AgentGen BEGIN=nlmConfigGlobalAgeOut::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigGlobalAgeOut
//--AgentGen END

/**
 *  nlmConfigLogFilterName
 *
 */

nlmConfigLogFilterName::nlmConfigLogFilterName(const Oidx& id)
    : MibLeaf(id, READCREATE, new OctetStr(""), VMODE_DEFAULT)
{
    //--AgentGen BEGIN=nlmConfigLogFilterName::nlmConfigLogFilterName
    //--AgentGen END
}

nlmConfigLogFilterName::~nlmConfigLogFilterName()
{
    //--AgentGen BEGIN=nlmConfigLogFilterName::~nlmConfigLogFilterName
    //--AgentGen END
}

MibEntryPtr nlmConfigLogFilterName::clone()
{
    MibEntryPtr other = new nlmConfigLogFilterName(oid);

    ((nlmConfigLogFilterName*)other)->replace_value(value->clone());
    ((nlmConfigLogFilterName*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nlmConfigLogFilterName::clone
    //--AgentGen END
    return other;
}

void nlmConfigLogFilterName::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmConfigLogFilterName::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

OctetStr nlmConfigLogFilterName::get_state() { return *((OctetStr*)value); }

void nlmConfigLogFilterName::set_state(const OctetStr& s)
{
    //--AgentGen BEGIN=nlmConfigLogFilterName::set_state
    //--AgentGen END
    *((OctetStr*)value) = s;
}

int nlmConfigLogFilterName::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigLogFilterName::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

bool nlmConfigLogFilterName::value_ok(const Vbx& vb)
{
    OctetStr v;

    if (vb.get_value(v) != SNMP_CLASS_SUCCESS)
    {
        return false;
    }

    //--AgentGen BEGIN=nlmConfigLogFilterName::value_ok
    //--AgentGen END
    return true;
}

int nlmConfigLogFilterName::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = MibLeaf::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }
    Vb const vb(req->get_value(ind));
    OctetStr v;
    if (vb.get_value(v) != SNMP_CLASS_SUCCESS)
    {
        return SNMP_ERROR_WRONG_TYPE;
    }
    if (!(v.len() <= 32))
    {
        return SNMP_ERROR_WRONG_LENGTH;
    }

    //--AgentGen BEGIN=nlmConfigLogFilterName::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigLogFilterName
//--AgentGen END

/**
 *  nlmConfigLogEntryLimit
 *
 */

nlmConfigLogEntryLimit::nlmConfigLogEntryLimit(const Oidx& id)
    : MibLeaf(id, READCREATE, new Gauge32(0), VMODE_DEFAULT)
{
    //--AgentGen BEGIN=nlmConfigLogEntryLimit::nlmConfigLogEntryLimit
    //--AgentGen END
}

nlmConfigLogEntryLimit::~nlmConfigLogEntryLimit()
{
    //--AgentGen BEGIN=nlmConfigLogEntryLimit::~nlmConfigLogEntryLimit
    //--AgentGen END
}

MibEntryPtr nlmConfigLogEntryLimit::clone()
{
    MibEntryPtr other = new nlmConfigLogEntryLimit(oid);

    ((nlmConfigLogEntryLimit*)other)->replace_value(value->clone());
    ((nlmConfigLogEntryLimit*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nlmConfigLogEntryLimit::clone
    //--AgentGen END
    return other;
}

void nlmConfigLogEntryLimit::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmConfigLogEntryLimit::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

uint32_t nlmConfigLogEntryLimit::get_state() { return (uint32_t) * ((Gauge32*)value); }

void nlmConfigLogEntryLimit::set_state(uint32_t l)
{
    //--AgentGen BEGIN=nlmConfigLogEntryLimit::set_state
    //--AgentGen END
    *((Gauge32*)value) = l;
}

int nlmConfigLogEntryLimit::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigLogEntryLimit::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

bool nlmConfigLogEntryLimit::value_ok(const Vbx& /*vb*/)
{
    //--AgentGen BEGIN=nlmConfigLogEntryLimit::value_ok
    //--AgentGen END
    return true;
}

int nlmConfigLogEntryLimit::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = MibLeaf::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    //--AgentGen BEGIN=nlmConfigLogEntryLimit::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigLogEntryLimit
//--AgentGen END

/**
 *  nlmConfigLogAdminStatus
 *
 */

nlmConfigLogAdminStatus::nlmConfigLogAdminStatus(const Oidx& id)
    : MibLeaf(id, READCREATE, new SnmpInt32(1), VMODE_DEFAULT)
{
    //--AgentGen BEGIN=nlmConfigLogAdminStatus::nlmConfigLogAdminStatus
    //--AgentGen END
}

nlmConfigLogAdminStatus::~nlmConfigLogAdminStatus()
{
    //--AgentGen BEGIN=nlmConfigLogAdminStatus::~nlmConfigLogAdminStatus
    //--AgentGen END
}

MibEntryPtr nlmConfigLogAdminStatus::clone()
{
    MibEntryPtr other = new nlmConfigLogAdminStatus(oid);

    ((nlmConfigLogAdminStatus*)other)->replace_value(value->clone());
    ((nlmConfigLogAdminStatus*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nlmConfigLogAdminStatus::clone
    //--AgentGen END
    return other;
}

void nlmConfigLogAdminStatus::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmConfigLogAdminStatus::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int32_t nlmConfigLogAdminStatus::get_state() { return (int32_t) * ((SnmpInt32*)value); }

void nlmConfigLogAdminStatus::set_state(int32_t l)
{
    //--AgentGen BEGIN=nlmConfigLogAdminStatus::set_state
    //--AgentGen END
    *((SnmpInt32*)value) = l;
}

int nlmConfigLogAdminStatus::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigLogAdminStatus::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

bool nlmConfigLogAdminStatus::value_ok(const Vbx& vb)
{
    int32_t v = 0;

    if (vb.get_value(v) != SNMP_CLASS_SUCCESS)
    {
        return false;
    }
    if ((v != 1) && (v != 2))
    {
        return false;
    }

    //--AgentGen BEGIN=nlmConfigLogAdminStatus::value_ok
    //--AgentGen END
    return true;
}

int nlmConfigLogAdminStatus::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = MibLeaf::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    //--AgentGen BEGIN=nlmConfigLogAdminStatus::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigLogAdminStatus
//--AgentGen END

/**
 *  nlmConfigLogStorageType
 *
 */

nlmConfigLogStorageType::nlmConfigLogStorageType(const Oidx& id) : StorageType(id, 3)
{
    //--AgentGen BEGIN=nlmConfigLogStorageType::nlmConfigLogStorageType
    //--AgentGen END
}

nlmConfigLogStorageType::~nlmConfigLogStorageType()
{
    //--AgentGen BEGIN=nlmConfigLogStorageType::~nlmConfigLogStorageType
    //--AgentGen END
}

MibEntryPtr nlmConfigLogStorageType::clone()
{
    MibEntryPtr other = new nlmConfigLogStorageType(oid);

    ((nlmConfigLogStorageType*)other)->replace_value(value->clone());
    ((nlmConfigLogStorageType*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nlmConfigLogStorageType::clone
    //--AgentGen END
    return other;
}

void nlmConfigLogStorageType::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmConfigLogStorageType::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

int32_t nlmConfigLogStorageType::get_state() { return (int32_t) * ((SnmpInt32*)value); }

void nlmConfigLogStorageType::set_state(int32_t l)
{
    //--AgentGen BEGIN=nlmConfigLogStorageType::set_state
    //--AgentGen END
    *((SnmpInt32*)value) = l;
}

int nlmConfigLogStorageType::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigLogStorageType::set
    //--AgentGen END
    return MibLeaf::set(vb);
}

bool nlmConfigLogStorageType::value_ok(const Vbx& vb)
{
    int32_t v = 0;

    if (vb.get_value(v) != SNMP_CLASS_SUCCESS)
    {
        return false;
    }
    if ((v < 1) || (v > 5))
    {
        return false;
    }

    //--AgentGen BEGIN=nlmConfigLogStorageType::value_ok
    //--AgentGen END
    return true;
}

int nlmConfigLogStorageType::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = StorageType::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    //--AgentGen BEGIN=nlmConfigLogStorageType::prepare_set_request
    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigLogStorageType
//--AgentGen END

/**
 *  nlmConfigLogEntryStatus
 *
 */

nlmConfigLogEntryStatus::nlmConfigLogEntryStatus(const Oidx& id) : snmpRowStatus(id, READCREATE)

{
    //--AgentGen BEGIN=nlmConfigLogEntryStatus::nlmConfigLogEntryStatus
    //--AgentGen END
}

nlmConfigLogEntryStatus::~nlmConfigLogEntryStatus()
{
    //--AgentGen BEGIN=nlmConfigLogEntryStatus::~nlmConfigLogEntryStatus
    //--AgentGen END
}

MibEntryPtr nlmConfigLogEntryStatus::clone()
{
    MibEntryPtr other = new nlmConfigLogEntryStatus(oid);

    ((nlmConfigLogEntryStatus*)other)->replace_value(value->clone());
    ((nlmConfigLogEntryStatus*)other)->set_reference_to_table(my_table);

    //--AgentGen BEGIN=nlmConfigLogEntryStatus::clone
    //--AgentGen END
    return other;
}

int32_t nlmConfigLogEntryStatus::get_state() { return (int32_t) * ((SnmpInt32*)value); }

void nlmConfigLogEntryStatus::set_state(int32_t l)
{
    //--AgentGen BEGIN=nlmConfigLogEntryStatus::set_state
    //--AgentGen END
    *((SnmpInt32*)value) = l;
}

int nlmConfigLogEntryStatus::set(const Vbx& vb)
{
    //--AgentGen BEGIN=nlmConfigLogEntryStatus::set
    //--AgentGen END
    return snmpRowStatus::set(vb);
}

int nlmConfigLogEntryStatus::prepare_set_request(Request* req, int& ind)
{
    int status = 0;

    if ((status = snmpRowStatus::prepare_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    //--AgentGen BEGIN=nlmConfigLogEntryStatus::prepare_set_request
    Vbx const vb(req->get_value(ind));
    int32_t   l = 0;
    if (vb.get_value(l) != SNMP_CLASS_SUCCESS)
    {
        return SNMP_ERROR_WRONG_TYPE;
    }

    if ((l == rowCreateAndGo) || (l == rowActive))
    {
        // initialize viewName;
        OctetStr secName, viewName;
        req->get_security_name(secName);
        int const vacmErrorCode =
            ((nlmConfigLogEntry*)my_table)
                ->mib->get_request_list()
                ->get_vacm()
                ->getViewName(req->get_security_model(), secName, req->get_pdu()->get_security_level(),
                    mibView_notify, req->get_context(), viewName);
        if (vacmErrorCode != VACM_viewFound)
        {
            return SNMP_ERROR_NO_ACCESS;
        }
    }

    //--AgentGen END
    return SNMP_ERROR_SUCCESS;
}

//--AgentGen BEGIN=nlmConfigLogEntryStatus

int nlmConfigLogEntryStatus::commit_set_request(Request* req, int ind)
{
    int status = 0;

    if ((status = snmpRowStatus::commit_set_request(req, ind)) != SNMP_ERROR_SUCCESS)
    {
        return status;
    }

    // save security info for further reference
    Vbx const vb(req->get_value(ind));
    int32_t   l = 0;
    vb.get_value(l);
    if ((l == rowCreateAndGo) || (l == rowActive))
    {
        // initialize viewName;
        OctetStr secName, viewName;
        req->get_security_name(secName);
        int const vacmErrorCode =
            ((nlmConfigLogEntry*)my_table)
                ->mib->get_request_list()
                ->get_vacm()
                ->getViewName(req->get_security_model(), secName, req->get_pdu()->get_security_level(),
                    mibView_notify, req->get_context(), viewName);
        if (vacmErrorCode != VACM_viewFound)
        {
            return SNMP_ERROR_COMMITFAIL;
        }

        // NOTE: this is the hidden row HACK! CK
        my_row->get_nth(nNlmConfigLogEntryStatus + 1)->set_value(viewName);
    }

    return SNMP_ERROR_SUCCESS;
}

//--AgentGen END

/**
 *  nlmStatsGlobalNotificationsLogged
 *
 */

nlmStatsGlobalNotificationsLogged* nlmStatsGlobalNotificationsLogged::instance = nullptr;

nlmStatsGlobalNotificationsLogged::nlmStatsGlobalNotificationsLogged()
    : Counter32MibLeaf(oidNlmStatsGlobalNotificationsLogged)
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer nlmStatsGlobalNotificationsLogged::instance.
    instance = this;

    //--AgentGen BEGIN=nlmStatsGlobalNotificationsLogged::nlmStatsGlobalNotificationsLogged
    //--AgentGen END
}

nlmStatsGlobalNotificationsLogged::~nlmStatsGlobalNotificationsLogged()
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsLogged::~nlmStatsGlobalNotificationsLogged
    //--AgentGen END
}

void nlmStatsGlobalNotificationsLogged::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsLogged::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

uint32_t nlmStatsGlobalNotificationsLogged::get_state() { return (uint32_t) * ((Counter32*)value); }

void nlmStatsGlobalNotificationsLogged::set_state(uint32_t l)
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsLogged::set_state
    //--AgentGen END
    *((Counter32*)value) = l;
}

uint32_t nlmStatsGlobalNotificationsLogged::inc()
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsLogged::inc
    //--AgentGen END
    uint32_t l = get_state();

    set_state(++l);
    return l;
}

//--AgentGen BEGIN=nlmStatsGlobalNotificationsLogged
//--AgentGen END

/**
 *  nlmStatsGlobalNotificationsBumped
 *
 */

nlmStatsGlobalNotificationsBumped* nlmStatsGlobalNotificationsBumped::instance = nullptr;

nlmStatsGlobalNotificationsBumped::nlmStatsGlobalNotificationsBumped()
    : Counter32MibLeaf(oidNlmStatsGlobalNotificationsBumped)
{
    // This leaf object is a singleton. In order to access it use
    // the static pointer nlmStatsGlobalNotificationsBumped::instance.
    instance = this;

    //--AgentGen BEGIN=nlmStatsGlobalNotificationsBumped::nlmStatsGlobalNotificationsBumped
    //--AgentGen END
}

nlmStatsGlobalNotificationsBumped::~nlmStatsGlobalNotificationsBumped()
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsBumped::~nlmStatsGlobalNotificationsBumped
    //--AgentGen END
}

void nlmStatsGlobalNotificationsBumped::get_request(Request* req, int ind)
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsBumped::get_request
    //--AgentGen END
    MibLeaf::get_request(req, ind);
}

uint32_t nlmStatsGlobalNotificationsBumped::get_state() { return (uint32_t) * ((Counter32*)value); }

void nlmStatsGlobalNotificationsBumped::set_state(uint32_t l)
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsBumped::set_state
    //--AgentGen END
    *((Counter32*)value) = l;
}

uint32_t nlmStatsGlobalNotificationsBumped::inc()
{
    //--AgentGen BEGIN=nlmStatsGlobalNotificationsBumped::inc
    //--AgentGen END
    uint32_t l = get_state();

    set_state(++l);
    return l;
}

//--AgentGen BEGIN=nlmStatsGlobalNotificationsBumped
//--AgentGen END

/**
 *  nlmConfigLogEntry
 *
 */

nlmConfigLogEntry* nlmConfigLogEntry::instance = nullptr;

const index_info indNlmConfigLogEntry[1] = { { sNMP_SYNTAX_OCTETS, false, 0, 255 } };

nlmConfigLogEntry::nlmConfigLogEntry(Mib* _mib)
    : StorageTable(oidNlmConfigLogEntry, indNlmConfigLogEntry, 1), mib(_mib)
{
    // This table object is a singleton. In order to access it use
    // the static pointer nlmConfigLogEntry::instance.
    instance = this;

    add_col(new nlmConfigLogFilterName(colNlmConfigLogFilterName));
    add_col(new nlmConfigLogEntryLimit(colNlmConfigLogEntryLimit));
    add_col(new nlmConfigLogAdminStatus(colNlmConfigLogAdminStatus));
    //XXX add_col(new nlmConfigLogOperStatus(colNlmConfigLogOperStatus));
    add_col(new MibLeaf(colNlmConfigLogOperStatus, READONLY, new SnmpInt32(2)));
    add_storage_col(new nlmConfigLogStorageType(colNlmConfigLogStorageType));
    add_col(new nlmConfigLogEntryStatus(colNlmConfigLogEntryStatus));

    //--AgentGen BEGIN=nlmConfigLogEntry::nlmConfigLogEntry
    //XXX replace_col(nNlmConfigLogOperStatus, new nlmConfigLogOperStatus(colNlmConfigLogOperStatus));

    // NOTE: this is the hidden row HACK! CK
    // create an hidden row at nNlmConfigLogEntryStatus + 1! CK
    add_col(new MibLeaf("100", NOACCESS, new OctetStr())); // viewName
    //--AgentGen END
}

nlmConfigLogEntry::~nlmConfigLogEntry()
{
    //--AgentGen BEGIN=nlmConfigLogEntry::~nlmConfigLogEntry
    //--AgentGen END
}

void nlmConfigLogEntry::row_added(MibTableRow* /*row*/, const Oidx& /*index*/, MibTable* /*src*/)
{
    // The row 'row' with 'index' has been added to the table.

    //--AgentGen BEGIN=nlmConfigLogEntry::row_added
    //--AgentGen END
}

void nlmConfigLogEntry::row_delete(MibTableRow* /*row*/, const Oidx& /*index*/, MibTable* /*src*/)
{
    // The row 'row' with 'index' will be deleted.

    //--AgentGen BEGIN=nlmConfigLogEntry::row_delete
    //--AgentGen END
}

void nlmConfigLogEntry::row_init(MibTableRow* /*row*/, const Oidx& /*index*/, MibTable* /*src*/)
{
    // The row 'row' with 'index' has been initialized.

    //--AgentGen BEGIN=nlmConfigLogEntry::row_init
    //--AgentGen END
}

void nlmConfigLogEntry::set_row(
    MibTableRow* r, const OctetStr& p0, uint32_t p1, int32_t p2, int32_t p3, int32_t p4, int32_t p5)
{
    r->get_nth(0)->replace_value(new OctetStr(p0));
    r->get_nth(1)->replace_value(new Gauge32(p1));
    r->get_nth(2)->replace_value(new SnmpInt32(p2));
    r->get_nth(3)->replace_value(new SnmpInt32(p3));
    r->get_nth(4)->replace_value(new SnmpInt32(p4));
    r->get_nth(5)->replace_value(new SnmpInt32(p5));
}

//--AgentGen BEGIN=nlmConfigLogEntry
//--AgentGen END

/**
 *  nlmStatsLogEntry
 *
 */

nlmStatsLogEntry* nlmStatsLogEntry::instance = nullptr;

const index_info indNlmStatsLogEntry[1] = { { sNMP_SYNTAX_OCTETS, false, 0, 255 } };

nlmStatsLogEntry::nlmStatsLogEntry(nlmConfigLogEntry* configLogEntry)
    : MibTable(oidNlmStatsLogEntry, indNlmStatsLogEntry, 1), configLogEntry(configLogEntry)
{
    // This table object is a singleton. In order to access it use
    // the static pointer nlmStatsLogEntry::instance.
    instance = this;

    add_col(new MibLeaf(colNlmStatsLogNotificationsLogged, READONLY, new Counter32()));
    add_col(new MibLeaf(colNlmStatsLogNotificationsBumped, READONLY, new Counter32()));

    //--AgentGen BEGIN=nlmStatsLogEntry::nlmStatsLogEntry
    configLogEntry->add_listener(this);
    //--AgentGen END
}

nlmStatsLogEntry::~nlmStatsLogEntry()
{
    //--AgentGen BEGIN=nlmStatsLogEntry::~nlmStatsLogEntry
    // TODO: We cannot be sure that configLogEntry is still valid when this
    // destructor is being called!
    // if (configLogEntry) {
    //    configLogEntry->remove_listener(this);
    //}
    //--AgentGen END
}

void nlmStatsLogEntry::row_added(MibTableRow* /*row*/, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been added to the table.

    //--AgentGen BEGIN=nlmStatsLogEntry::row_added
    if (src)
    {
        add_row(index);
    }
    //--AgentGen END
}

void nlmStatsLogEntry::row_delete(MibTableRow* /*row*/, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' will be deleted.

    //--AgentGen BEGIN=nlmStatsLogEntry::row_delete
    if (src)
    {
        remove_row(index);
    }
    //--AgentGen END
}

void nlmStatsLogEntry::row_init(MibTableRow* /*row*/, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been intialized.

    //--AgentGen BEGIN=nlmStatsLogEntry::row_init
    if (src)
    {
        add_row(index);
    }
    //--AgentGen END
}

void nlmStatsLogEntry::set_row(MibTableRow* r, uint32_t p0, uint32_t p1)
{
    r->get_nth(0)->replace_value(new Counter32(p0));
    r->get_nth(1)->replace_value(new Counter32(p1));
}

//--AgentGen BEGIN=nlmStatsLogEntry
//--AgentGen END

/**
 *  nlmLogEntry
 *
 */

nlmLogEntry* nlmLogEntry::instance = nullptr;

const index_info indNlmLogEntry[2] = { { sNMP_SYNTAX_OCTETS, false, 0, 255 },
    { sNMP_SYNTAX_INT, false, 1, 1 } };

nlmLogEntry::nlmLogEntry(Mib* _mib, nlmConfigLogEntry* configLogEntry, nlmStatsLogEntry* statsLogEntry,
    nlmLogVariableEntry* logVariableEntry, nlmConfigGlobalEntryLimit* configGlobalEntryLimit,
    nlmConfigGlobalAgeOut* configGlobalAgeOut)
    : MibTable(oidNlmLogEntry, indNlmLogEntry, 2), mib(_mib), configLogEntry(configLogEntry),
      statsLogEntry(statsLogEntry), logVariableEntry(logVariableEntry),
      configGlobalEntryLimit(configGlobalEntryLimit), configGlobalAgeOut(configGlobalAgeOut)
{
    // This table object is a singleton. In order to access it use
    // the static pointer nlmLogEntry::instance.
    instance = this;

    add_col(new MibLeaf(colNlmLogTime, READONLY, new TimeTicks()));
    add_col(new MibLeaf(colNlmLogDateAndTime, READONLY, new OctetStr()));
    add_col(new MibLeaf(colNlmLogEngineID, READONLY, new OctetStr()));
    add_col(new MibLeaf(colNlmLogEngineTAddress, READONLY, new OctetStr()));
    add_col(new MibLeaf(colNlmLogEngineTDomain, READONLY, new Oid()));
    add_col(new MibLeaf(colNlmLogContextEngineID, READONLY, new OctetStr()));
    add_col(new MibLeaf(colNlmLogContextName, READONLY, new OctetStr()));
    add_col(new MibLeaf(colNlmLogNotificationID, READONLY, new Oid()));

    //--AgentGen BEGIN=nlmLogEntry::nlmLogEntry
    replace_col(nNlmLogDateAndTime, new DateAndTime(colNlmLogDateAndTime, READONLY, VMODE_DEFAULT));
    if (configLogEntry)
    {
        configLogEntry->add_listener(this);
    }
    add_listener(logVariableEntry);
    //--AgentGen END
}

nlmLogEntry::~nlmLogEntry()
{
    //--AgentGen BEGIN=nlmLogEntry::~nlmLogEntry
    remove_listener(logVariableEntry);
    // TODO: We cannot be sure that configLogEntry is still valid when this
    // destructor is being called!
    // if (configLogEntry) {
    //    configLogEntry->remove_listener(this);
    //}
    entries.clear();
    //--AgentGen END
}

void nlmLogEntry::row_added(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been added to the table.

    //--AgentGen BEGIN=nlmLogEntry::row_added
    // new log configuration?
    if (src == configLogEntry)
    {
        Vbx vb(index);
        vb.set_value(0ul);
        // add log index
        logIndexes.add(new MibStaticEntry(vb));
    }
    else
    {
        entries.add(row);
    }
    //--AgentGen END
}

void nlmLogEntry::row_delete(MibTableRow* row, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' will be deleted.

    //--AgentGen BEGIN=nlmLogEntry::row_delete
    if (src == configLogEntry)
    {
        Oidx ind(index);
        logIndexes.remove(&ind);
    }
    else
    {
        entries.remove(row);
    }
    //--AgentGen END
}

void nlmLogEntry::row_init(MibTableRow* /*row*/, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' has been initialized.

    //--AgentGen BEGIN=nlmLogEntry::row_init
    if (src == configLogEntry)
    {
        Vbx vb(index);
        vb.set_value(0ul);
        logIndexes.add(new MibStaticEntry(vb));
    }
    //--AgentGen END
}

void nlmLogEntry::set_row(MibTableRow* r, uint32_t p0, const OctetStr& p1, const OctetStr& p2,
    const OctetStr& p3, const char* p4, const OctetStr& p5, const OctetStr& p6, const char* p7)
{
    r->get_nth(0)->replace_value(new TimeTicks(p0));
    r->get_nth(1)->replace_value(new OctetStr(p1));
    r->get_nth(2)->replace_value(new OctetStr(p2));
    r->get_nth(3)->replace_value(new OctetStr(p3));
    r->get_nth(4)->replace_value(new Oid(p4));
    r->get_nth(5)->replace_value(new OctetStr(p5));
    r->get_nth(6)->replace_value(new OctetStr(p6));
    r->get_nth(7)->replace_value(new Oid(p7));
}

//--AgentGen BEGIN=nlmLogEntry

bool nlmLogEntry::check_access(const Vbx* vbs, const int size, const Oid& nid, MibTableRow* profile)
{
    OctetStr viewName;

    // NOTE: this is the hidden row HACK! CK
    if (profile->get_nth(nNlmConfigLogEntryStatus + 1)->get_value(viewName) == SNMP_ERROR_SUCCESS)
    {
        // an empty viewName denotes a system entry that automatically has access
        if (viewName.len() == 0)
        {
            return true;
        }
    }

    assert(viewName.len() > 0);
    bool accessAllowed = true;
    for (int i = 0; i < size; i++)
    {
        if (mib->get_request_list()->get_vacm()->isAccessAllowed(viewName, vbs[i].get_oid())
            != VACM_accessAllowed)
        {
            accessAllowed = false;
            break;
        }
    }

    if (accessAllowed)
    {
        accessAllowed = (mib->get_request_list()->get_vacm()->isAccessAllowed(viewName, nid)
            == VACM_accessAllowed);
    }

    if (!accessAllowed)
    {
        LOG_BEGIN(loggerModuleName, EVENT_LOG | 2);
        LOG("Notification not logged (reason)(viewName)");
        LOG("no access");
        LOG(viewName.get_printable());
        LOG_END;
    }

    return accessAllowed;
}

void nlmLogEntry::add_notification(const SnmpTarget* target, const Oid& nid, const Vbx* vbs,
    const int vbcount, const OctetStr& context, const OctetStr& ceid, const OctetStr& engineID)
{
    OctetStr address;

    if (target)
    {
        switch (target->get_type())
        {
        case SnmpTarget::type_ctarget: {
            [[fallthrough]];
        }
        case SnmpTarget::type_utarget: {
            break;
        }

        case SnmpTarget::type_base: {
            LOG_BEGIN(loggerModuleName, ERROR_LOG | 1);
            LOG("nlmLogEntry: invalid target given");
            LOG_END;
            return;
        }
        }
        GenAddress addr;
        target->get_address(addr);
        auto*     udpAddress = new UdpAddress(addr);
        IpAddress ip(*udpAddress);
        for (int i = 0; i < ip.get_length(); i++) { address += (unsigned char)ip[i]; }
        address += (udpAddress->get_port() >> 8);
        address += (udpAddress->get_port() & 0x00FF);
        delete udpAddress;
    }
    else
    {
        return;
    }

    LOG_BEGIN(loggerModuleName, EVENT_LOG | 5);
    LOG("NotificationLog: Logging (target)(oid)(vbs)");
    LOG(address.get_printable_hex());
    LOG(nid.get_printable());
    LOG(vbcount);
    LOG_END;

    start_synch();
    List<MibTableRow>* logs = configLogEntry->get_rows_cloned();
    statsLogEntry->start_synch();

    ListCursor<MibTableRow> cur;
    for (cur.init(logs); cur.get(); cur.next())
    {
        // ignore disabled log entries
        if (((nlmConfigLogAdminStatus*)cur.get()->get_nth(nNlmConfigLogAdminStatus))->get_state()
            == nlmConfigLogAdminStatus::e_disabled)
        {
            continue;
        }

        // check access
        OctetStr const profileName =
            ((nlmConfigLogFilterName*)cur.get()->get_nth(nNlmConfigLogFilterName))->get_state();
        if ((profileName.len() > 0) && (!check_access(vbs, vbcount, nid, cur.get())))
        {
            continue;
        }

        // check filter
        snmpNotifyFilterEntry* snmpNotifyFilterEntry = snmpNotifyFilterEntry::get_instance(mib);
        assert(snmpNotifyFilterEntry != nullptr);
        if ((profileName.len() == 0) && ((snmpNotifyFilterEntry)
                && (!snmpNotifyFilterEntry->passes_filter(
                    Oidx::from_string(profileName, true), nid, vbs, vbcount))))
        {
            continue;
        }

        // OK, now log the notification
        uint32_t l  = 0;
        Vbx*     vb = logIndexes.find(cur.get()->key());
        if (!vb)
        {
            continue;
        }

        vb->get_value(l);
        Oidx newIndex(cur.get()->get_index());
        newIndex += ++l;
        vb->set_value(l);

        MibTableRow* r = add_row(newIndex);
        set_row(r, sysUpTime::get(), ((DateAndTime*)r->get_nth(1))->get_state(), engineID, address,
            "1.3.6.1.6.1.1", ceid, context, nid.get_printable());

        logVariableEntry->start_synch();
        for (int i = 0; i < vbcount; i++) { logVariableEntry->add_variable(newIndex, i, vbs[i]); }
        logVariableEntry->end_synch();

        MibTableRow* s  = statsLogEntry->find_index(cur.get()->get_index());
        Counter32    ll = 0;
        if (s)
        {
            s->get_nth(nNlmStatsLogNotificationsLogged)->get_value(ll);
            ll = (uint32_t)ll + 1ul;
            s->get_nth(nNlmStatsLogNotificationsLogged)->set_value(ll);
            Counter32MibLeaf::incrementScalar(mib, oidNlmStatsGlobalNotificationsLogged);
        }
    }

    check_limits(logs);
    delete logs;

    statsLogEntry->end_synch();
    end_synch();
}

void nlmLogEntry::check_limits(List<MibTableRow>* logs)
{
    uint32_t const global_limit = configGlobalEntryLimit->get_state();
    if (global_limit > 0)
    {
        int32_t const v = size() - global_limit;
        if (v > 0)
        {
            ListCursor<MibTableRow> cur;
            int                     i = 0;
            for (cur.init(&entries); (i < v) && (cur.get());)
            {
                MibTableRow* victim = cur.get();
                cur.next();
                remove_row(victim->get_index());
                i++;
                Counter32MibLeaf::incrementScalar(mib, oidNlmStatsGlobalNotificationsBumped);
            }
        }
    }

    uint32_t const age_out = configGlobalAgeOut->get_state();
    if (age_out > 0)
    {
        ListCursor<MibTableRow> cur;
        uint32_t const          uptime = sysUpTime::get();
        for (cur.init(&entries); cur.get();)
        {
            MibTableRow* victim = cur.get();
            cur.next();
            uint32_t logtime = 0;
            victim->get_nth(nNlmLogTime)->get_value(logtime);
            // age_out counts minutes -> 60 * 100 1/100 seconds
            if (uptime - logtime > age_out * 6000)
            {
                Oidx profile(victim->get_index());
                profile.trim();
                MibTableRow* s = configLogEntry->find_index(profile);
                if (s)
                {
                    uint32_t ll = 0;
                    s->get_nth(nNlmStatsLogNotificationsBumped)->get_value(ll);
                    ll++;
                    s->get_nth(nNlmStatsLogNotificationsBumped)->set_value(ll);
                }
                remove_row(victim->get_index());
            }
            else
            {
                break;
            }
        }
    }

    ListCursor<MibTableRow> cur;
    for (cur.init(logs); cur.get(); cur.next())
    {
        uint32_t entry_limit = 0;
        cur.get()->get_nth(nNlmConfigLogEntryLimit)->get_value(entry_limit);
        if (entry_limit == 0)
        {
            continue;
        }

        OidListCursor<MibTableRow> c(&content);
        uint32_t                   n = 0;
        for (c.lookup(cur.get()->key()); c.get(); c.next())
        {
            Oidx const ind(c.get()->get_index().cut_right(1));
            if (ind > cur.get()->get_index())
            {
                break;
            }
            if (ind == cur.get()->get_index())
            {
                n++;
            }
        }
        if ((entry_limit > 0) && (n > entry_limit))
        {
            n = n - entry_limit;
            c.init(&content);
            for (c.lookup(cur.get()->key()); ((n > 0) && (c.get()));)
            {
                Oidx const ind(c.get()->get_index().cut_right(1));
                if (ind > cur.get()->get_index())
                {
                    break;
                }
                if (ind != cur.get()->get_index())
                {
                    c.next();
                    continue;
                }

                Counter32MibLeaf::incrementScalar(mib, oidNlmStatsGlobalNotificationsBumped);

                Counter32    ll;
                MibTableRow* r = statsLogEntry->find_index(cur.get()->get_index());
                if (r)
                {
                    MibLeaf* l = r->get_nth(nNlmStatsLogNotificationsBumped);
                    assert(l != nullptr);
                    l->get_value(ll);
                    ll = (uint32_t)ll + 1ul;
                    l->set_value(ll);
                }
                MibTableRow* victim = c.get();
                c.next();
                remove_row(victim->get_index());
                n--;
            }
        }
    }
}
//--AgentGen END

/**
 *  nlmLogVariableEntry
 *
 */

nlmLogVariableEntry* nlmLogVariableEntry::instance = nullptr;

const index_info indNlmLogVariableEntry[3] = { { sNMP_SYNTAX_OCTETS, false, 0, 255 },
    { sNMP_SYNTAX_INT, false, 1, 1 }, { sNMP_SYNTAX_INT, false, 1, 1 } };

nlmLogVariableEntry::nlmLogVariableEntry()
    : MibTable(oidNlmLogVariableEntry, indNlmLogVariableEntry, 3)
{
    // This table object is a singleton. In order to access it use
    // the static pointer nlmLogVariableEntry::instance.
    instance = this;

    add_col(new MibLeaf(colNlmLogVariableID, READONLY, new Oid()));
    add_col(new MibLeaf(colNlmLogVariableValueType, READONLY, new SnmpInt32()));
    add_col(new MibLeaf(colNlmLogVariableCounter32Val, READONLY, new Counter32()));
    add_col(new MibLeaf(colNlmLogVariableUnsigned32Val, READONLY, new Gauge32()));
    add_col(new MibLeaf(colNlmLogVariableTimeTicksVal, READONLY, new TimeTicks()));
    add_col(new MibLeaf(colNlmLogVariableInteger32Val, READONLY, new SnmpInt32()));
    add_col(new MibLeaf(colNlmLogVariableOctetStringVal, READONLY, new OctetStr()));
    add_col(new MibLeaf(colNlmLogVariableIpAddressVal, READONLY, new IpAddress("0.0.0.0")));
    add_col(new MibLeaf(colNlmLogVariableOidVal, READONLY, new Oid()));
    add_col(new MibLeaf(colNlmLogVariableCounter64Val, READONLY, new Counter64()));
    add_col(new MibLeaf(colNlmLogVariableOpaqueVal, READONLY, new OpaqueStr()));

    //--AgentGen BEGIN=nlmLogVariableEntry::nlmLogVariableEntry
    //--AgentGen END
}

nlmLogVariableEntry::~nlmLogVariableEntry()
{

    //--AgentGen BEGIN=nlmLogVariableEntry::~nlmLogVariableEntry
    //--AgentGen END
}

void nlmLogVariableEntry::row_added(MibTableRow* /*row*/, const Oidx& /*index*/, MibTable* /*src*/)
{
    // The row 'row' with 'index' has been added to the table.

    //--AgentGen BEGIN=nlmLogVariableEntry::row_added
    //--AgentGen END
}

void nlmLogVariableEntry::row_delete(MibTableRow* /*row*/, const Oidx& index, MibTable* src)
{
    // The row 'row' with 'index' will be deleted.

    //--AgentGen BEGIN=nlmLogVariableEntry::row_delete
    if ((src) && (*src->key() == Oidx(oidNlmLogEntry)))
    {
        OidListCursor<MibTableRow> cur(&content);
        Oidx                       ind(index);
        for (cur.lookup(&ind); ((cur.get()) && (cur.get()->get_index().cut_right(1) == index));)
        {
            MibTableRow* victim = cur.get();
            cur.next();
            remove_row(*victim->key());
        }
    }
    //--AgentGen END
}

void nlmLogVariableEntry::row_init(MibTableRow* /*row*/, const Oidx& /*index*/, MibTable* /*src*/)
{
    // The row 'row' with 'index' has been initialized.

    //--AgentGen BEGIN=nlmLogVariableEntry::row_init
    //--AgentGen END
}

void nlmLogVariableEntry::set_row(MibTableRow* r, const char* p0, int32_t p1, uint32_t p2, uint32_t p3,
    uint32_t p4, int32_t p5, const OctetStr& p6, const char* p7, const char* p8, uint32_t p9hi,
    uint32_t p9lo, const OctetStr& p10)
{
    r->get_nth(0)->replace_value(new Oid(p0));
    r->get_nth(1)->replace_value(new SnmpInt32(p1));
    r->get_nth(2)->replace_value(new Counter32(p2));
    r->get_nth(3)->replace_value(new Gauge32(p3));
    r->get_nth(4)->replace_value(new TimeTicks(p4));
    r->get_nth(5)->replace_value(new SnmpInt32(p5));
    r->get_nth(6)->replace_value(new OctetStr(p6));
    r->get_nth(7)->replace_value(new IpAddress(p7));
    r->get_nth(8)->replace_value(new Oid(p8));
    r->get_nth(9)->replace_value(new Counter64(p9hi, p9lo));
    r->get_nth(10)->replace_value(new OpaqueStr(p10));
}

//--AgentGen BEGIN=nlmLogVariableEntry
void nlmLogVariableEntry::add_variable(const Oidx& index, unsigned int i, const Vbx& vb)
{
    Oidx newIndex(index);
    newIndex += (uint32_t)i;
    MibTableRow* r = add_row(newIndex);
    for (int j = nNlmLogVariableCounter32Val; j < r->size(); j++)
    {
        r->get_nth(j)->set_access(NOACCESS);
    }
    r->get_nth(nNlmLogVariableID)->set_value(vb.get_oid());

    switch (vb.get_syntax())
    {
    case sNMP_SYNTAX_INT32: {
        r->get_nth(nNlmLogVariableInteger32Val)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableInteger32Val)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(4);
        break;
    }
    case sNMP_SYNTAX_TIMETICKS: {
        r->get_nth(nNlmLogVariableTimeTicksVal)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableTimeTicksVal)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(3);
        break;
    }
    case sNMP_SYNTAX_CNTR32: {
        r->get_nth(nNlmLogVariableCounter32Val)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableCounter32Val)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(1);
        break;
    }
    case sNMP_SYNTAX_GAUGE32: {
        r->get_nth(nNlmLogVariableUnsigned32Val)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableUnsigned32Val)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(2);
        break;
    }
    case sNMP_SYNTAX_CNTR64: {
        r->get_nth(nNlmLogVariableCounter64Val)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableCounter64Val)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(8);
        break;
    }
    case sNMP_SYNTAX_OCTETS: {
        [[fallthrough]];
    }
    case sNMP_SYNTAX_BITS: {
        r->get_nth(nNlmLogVariableOctetStringVal)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableOctetStringVal)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(6);
        break;
    }
    case sNMP_SYNTAX_OPAQUE: {
        auto* opaque = new OpaqueStr();
        vb.get_value(*opaque);
        r->get_nth(nNlmLogVariableOpaqueVal)->replace_value(opaque);
        r->get_nth(nNlmLogVariableOpaqueVal)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(9);
        break;
    }
    case sNMP_SYNTAX_IPADDR: {
        r->get_nth(nNlmLogVariableIpAddressVal)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableIpAddressVal)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(5);
        break;
    }
    case sNMP_SYNTAX_OID: {
        r->get_nth(nNlmLogVariableOidVal)->replace_value(vb.clone_value());
        r->get_nth(nNlmLogVariableOidVal)->set_access(READONLY);
        r->get_nth(nNlmLogVariableValueType)->set_value(7);
        break;
    }
    case sNMP_SYNTAX_NULL: {
        break;
    }
    }
}
//--AgentGen END

notification_log_mib::notification_log_mib() : notification_log_mib(Mib::instance) { }

notification_log_mib::notification_log_mib(Mib* mib)
    : MibGroup("1.3.6.1.2.1.92", "notificationLogMIB"), mib(mib)
{

    //--AgentGen BEGIN=notification_log_mib::notification_log_mib
    //--AgentGen END
    auto* _nlmConfigGlobalEntryLimit = new nlmConfigGlobalEntryLimit();
    add(_nlmConfigGlobalEntryLimit);

    auto* _nlmConfigGlobalAgeOut = new nlmConfigGlobalAgeOut();
    add(_nlmConfigGlobalAgeOut);

    auto* configLogEntry = new nlmConfigLogEntry(mib);
    add(configLogEntry);

    add(new nlmStatsGlobalNotificationsLogged());
    add(new nlmStatsGlobalNotificationsBumped());

    auto* statsLogEntry = new nlmStatsLogEntry(configLogEntry);
    add(statsLogEntry);

    auto* logVariableEntry = new nlmLogVariableEntry();
    add(logVariableEntry);
    add(new nlmLogEntry(mib, configLogEntry, statsLogEntry, logVariableEntry,
        _nlmConfigGlobalEntryLimit, _nlmConfigGlobalAgeOut));
}

//--AgentGen BEGIN=notification_log_mib
//--AgentGen END

//--AgentGen BEGIN=_END
#    ifdef AGENTPP_NAMESPACE
}
#    endif
#endif
//--AgentGen END
